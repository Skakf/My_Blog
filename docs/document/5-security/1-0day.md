---
title: 《0day漏洞分析》

tags: 读书笔记

---

# 第一章
## 漏洞概述：
- bug & Vulnerability：非预期错误，逻辑上缺陷+安全性缺陷
- 漏洞挖掘：本质上是一种测试（fuzz-灰盒测试）
- 漏洞分析：缓冲区溢出等等，通过逆向和调试，寻找PoC(proof of concept)重现漏洞被触发的现场。
- 漏洞利用：编写shellcode，exploit利用，形成攻击
- 0 day：指未被公布未被修复的漏洞，利用价值与危害最大，相应的还有1 day，5 day，即黑客们会在微软刚发布修补版本后研究这些补丁，寻找差异，未升级之前的一段时间都很危险

## 二进制概述
- PE文件
    文件偏移，Imagebase,VA，RVA，
    VA = ImageBase + RVA 

    文件偏移和RVA通常一样，但也可能不一样，因为有对齐（200，1000）
    
## 工具简介
    OD,SoftICE,IDA,Windbg
    
# 第二章
可以参考《深入理解计算机系统》
## 函数调用
   esp: 栈顶
   ebp: 最上面栈的基地址
   eip：指令寄存器，指向下一条等待执行的指令（控制它就控制了程序执行流程）
   
   参数入栈，函数返回时恢复栈平衡（在母函数或子函数中进行）
   
   步骤：
   1）局部变量，参数入栈        push 参数
   2）返回地址入栈              call funcA 完成2，3两个动作
   3）代码跳转
   4）栈帧调整
    - push ebp                  （保存当前栈帧状态值，以备后续恢复本栈帧）
    - mov ebp,esp               （更新栈底）
    - sub esp,xxx               （抬高栈顶，开辟新栈帧）
  
   
   eg：main(){funcA();}
    
        参数
    funcA的局部变量                <---funcA栈帧
        前栈帧ebp        <---ebp1
        返回地址         <---call funcA的下一条指令
        参数2
        参数1            （参数从右往左入栈）
        局部变量         <--- (main函数栈帧) ebp1   -->
        
    
## 函数返回
    
    步骤：
    1）保存返回值（给eax）
    2）回收当前栈帧
        - add esp，xxx
        - pop ebp，
        - retn (返回地址弹给eip，代码跳去返回地址，恢复调用前的代码区）
    3) 跳转
        
## 案例攻击方法
1）修改邻接变量。相当于修改了用于判断的返回值，通过溢出跳转到if成功分支
2）修改返回地址。相当于直接跳转到if成功分支
3）代码植入。 汇编转机器码，跳转到攻击代码，执行我们想让他做的事



