## P2IM: 通过自动外围接口建模 进行可伸缩且与硬件无关的 固件测试

摘要：

嵌入式固件的动态测试或模糊测试受到硬件依赖和可伸缩性差的严重限制，在一定程度上导致了普遍存在的脆弱物联网设备。提出一个软件框架，可以连续的执行给定的固件二进制文件，同时从一个现成的fuzzer里引导输入，从而支持独立于硬件和可伸缩的固件测试。

本框架使用P2IM 新技术，对各种外围设备进行抽象，并基于自动生成的模型 动态处理固件I/O 

P2IM不关心 外围设计和固件实现，因此适用于各种嵌入式设备。

70个示例固件，10个来自于真实设备的固件，来评估，成功执行了79%的样本固件，没有手动帮助，有限的模糊测试，发现7个独立未知的bug

### 介绍

微控制器（MCU）  软件漏洞对MCU设备的攻击

MCU固件，（MCU软件栈）存在漏洞。所以如果能够用在计算机上的测试方法模糊测试能用到MCU固件上就最理想了。然而实际现成的不能直接测试固件，这在一定程度上导致许多固件没有对安全漏洞的足够测试。【现状】

fuzzers在MCU上的不适用性归结于缺乏一个平台.固件可以在从fuzzer获取输入的同时执行.现有的仿真器无法仿真整个MCU外围设备(即无法运行固件).

最近有些工作使用混合仿真解决了这个问题,将外围操作转发到实际设备.尽管这种方法创建了一个使用fuzzer运行固件的平台,但是这个平台相当慢,并且由于对硬件的依赖,很难扩展

本文设计了一个框架,运行和测试大规模的MCU固件，以一个固件二进制文件作为输入，并以一个未修改的fuzzer（AFL）作为drop-in组件,使用通用处理器模拟器(QEMU)该框架执行固件并处理其外围访问,同时引导模糊输入和模糊器之间的反馈.

关键技术P2IM(处理器外围接口建模),会自动对各种外围设备的I/O行为建模,同时将外围设备本身视为黑盒,生成的模型满足我们制定的一个属性,称为处理器外围接口等价。 当该属性得到满足，固件的模拟执行可以顺利的继续（没有崩溃停止或跳过外围操作）而不需要依赖任何的外围设备，（无论是真实的还是模拟的）

### 概述

MCU固件通常是一个包含外围设备驱动程序额度、一个小型操作系统或系统库以及一组专门的逻辑或应用程序的单片软件

#### 挑战

模糊器直接大规模的在固件上工作，帮助发现漏洞，减少漏洞，提高MCU设备安全性

- 硬件依赖
  - 数量级延迟、严重限制并行性

- 外围设备范围广
  - 完全基于仿真的固件模糊测试，但是完全仿真是不切实际的。而且现有的仿真器没有提供通用的MCU支持，每个固件与一组不同的外围设备交互，因此通常需要一个专门定制的模拟器来模糊测试新固件

- 不同的操作系统/系统设计
  - 固件模糊测试面临的与软件相关的独特挑战是:模糊化生成的输入通过接口被引导到固件执行。对于计算机软件，输入接口定义良好且统一（文件或标准I/O）但是固件终的不同驱动程序可能会以不同的方式配置相同的外设，然后通过不同的接口执行I/O，因此，现有的模糊器支持输入接口与固件不兼容。手动向fuzzer添加对每个I/O接口的支持也是一项艰巨的任务

#### 方法

提出了一种新的固件模糊的方法，克服之前所讨论的挑战。

模糊器和固件之间架起一道桥梁，提供了一种基于固件二进制文件自动生成近似仿真器的方法。观察得到:固件可以在没有真实或完全仿真的外围设备情况下在仿真器上执行，只要仿真器提供固件必要时可接受外围设备的输入。这些输入不必与真正的外围设备产生的输入相同，但他们确实需要通过固件的内部检查，以避免中断固件的执行。对于给定的固件，我们的近似仿真器使用通用处理器，和为固件自动构建的模型，捕获固件访问的每个外设的可接受输入。我们发现，这种近似仿真可以全面的运行一个固件，足以支持fuzzing，因为这些分析检查固件的控制或数据行为，而不是测试功能的正确性

1）外围接口背景知识

片上外设：充当数据在固件和片外外设之间传输的代理

本文考虑 片内外设

2）属性

PIE（处理器外围接口等价）

满足这个特性意味：（1）模拟器模拟处理器外围接口，而不是固件使用的外围设备本身

（2）模拟的接口在对固件执行的影响方面，与固件期望的外围设备相同

我们注意到提供等效的处理器外围接口就足以使通用仿真程序在不使用任何外围仿真的情况下全面执行和测试fuzz固件。支持p2i的模拟器通过处理器外围接口和模拟他们的外部行为来处理外围io操作。

3）框架的高级设计

---

一。抽象模型设计

如图，对外围接口建模的第一步时为目标MCU体系结构类构建抽象模型，唯一的手动步骤，。

例如ARM-Cortex-M 定义一个抽象模型，是物联网设备最流行的架构类，可作为其他MCU架构构建抽象模型的模板。该模型将外围寄存器概括为四种类型，并为每种类型提供访问模式和处理策略。（例如，模拟器应该如何识别每种类型的寄存器，如何根据他的类型处理她对外围寄存器的访问。这种基于访问模式的寄存器类型识别  和  基于类型的寄存器访问处理通常适用于cortex-M 上的所有外设，因此，仿真器可以执行他们而不需要任何关于特定外设的知识，或外围设备的内部设计知识。

该模型将外部中断触发抽象为一个特殊的输入通道，并允许定制中断触发策略。

抽象模型还包括基本内存段的位置。（例如RAM，flash，映射寄存器区域）这些位置对使用相同MCU体系结构的设备是相同的，而且在MCU文档中明确过。



1、寄存器分类与访问模式 与处理

CR、SR、DR、C&SR

CR（Control控制寄存器）、

SR、(Status状态寄存器)

DR、（Data数据寄存器）

C&SR （Control-Status 控制状态寄存器）

注：虽然寄存器访问模式和类型识别方法纯粹是经验主义，但发现在实践中，他们在广泛的外围设备上工作的相当可靠和准确，原因：1）本文定义的寄存器类型一般适用于所有外设（2）从多种真实的MCU设备中观察并归纳出基于类型的访问模式

2、中断（抽象模型定义了仿真器应该如何代表外设触发必要的中断，以满足p2ie并支持持续的固件执行或测试）

本质上，中断是固件的一种特殊类型的输入，他们将某些硬件事件通知固件，并触发相应的中断服务例程（ISR），ISR是由固件中的外围驱动程序实现的中断处理程序。例如：一个中断可能表示输入数据的固件已经准备好了，然后调用相应的ISR并从DR中读取输入数据 。

PIM将中断抽象的建模为基于时间的输入序列，每个输入对应于一个已启用的中断。当这样的输入进来时，模拟器生成并将匹配的中断发送到固件。模拟器检测固件在运行时启用了那些中断，。

本原型使用了一个简单的中断触发策略，启用的中断以循环的方式在固定的时间间隔内触发（例如每执行1000个基本块之后）间隔用执行的基本快来确定。使用基于块计数来测量中断间隔允许中断序列的确定性重放，因此产生可重复的模糊测试结果。

3、不可行的外围输入

目前的抽象模型定义下，PIM可以触发固件中在实际设备上不可行的代码路径。这是因为硬件外围设备可能只生成特定的输入并在特定模式下触发中断，而PIM允许fuzzers生成随机的外围输入或采用任意的中断定时，

二、自动模型实例化

如图3，P2IM的第二步是第一步定义的抽象模型的模型实例化。为给定的固件生成完整的模型，实例化模型需要通过流程外围接口指导模拟器识别和处理io操作。在实例化步骤中，提供p2ie所需的特定于固件的信息被添加到抽象模型里。模型实例化过程完全自动化，并使用了探索性执行技术。实例化随需应变，并与固件模糊测试过程交织在一起，当模糊化过程遇到未建模或未处理的情况时，他将调用模型实例化过程。当模型变得稳定且没有新信息时，模型实例化过程终止，。称每次模型实例化过程调用为一轮模型实例化。在整个固件模糊化测试过程中，在不同的点上可以进行多轮模型实例化。这个过程依赖于一个定制的qemu，模拟cortex-M指令集和一个通用的中断控制器，而不是MCU外围设备。

具体来说，一个实例化的模型包括以下自动推断的固件特定信息，这些信息具体化了抽象的模型，（1）识别的内存映射寄存器、他们的内存位置和类型

（2）每一类寄存器的访问处理策略，或在需要时每个使用站点的访问处理策略。

（3）启用的中断和触发策略

流程图：模型实例化工作流程

在不模拟任何外设的通用处理器模拟器上执行固件，当固件访问处理器外围接口时，他不断实例化模型。在访问寄存器时，如果有必要，她重新对寄存器进行分类，对于SR读，检查是否存在处理程序，如果不是，执行探索性执行来自动生成一个处理程序。还通过固件监视中断配置，并在需要时触发中断。

---

P2IM为基于类型的寄存器访问处理提供了策略，在寄存器访问时指示模拟器应该采取什么操作，包括向固件返回什么值或者要更新什么内部状态。处理DR和CR访问很简单，而且在固件之间是一致的。时抽象模型定义里的一部分。

另一方面，处理SR和C&SR中的SR位，要复杂得多。在不同SR以及相同的SR的不同使用地点，策略都可能有所不同。例如，最重要的bit位，在两个不同的SR寄存器中，SR1和SR2 就有不同的涵义。在固件执行中，可能在SR1里设置这个bit位是希望固件继续执行，不要停机，但在SR2 设置了这bit位就固件也许会崩溃。因此，在固件执行的不同点，设置bit位会导致相反的结果，所以处理SR寄存器的访问策略需要考虑固件细节，各个寄存器及其访问上下文。作为模型实例化的一部分，P2IM使用了探索性执行的技术自动派生SR处理策略。

**探索性执行**

高级思想在于：当固件执行遇到新的SR访问site，PIM会暂停和快照执行（暂停，并给当前执行打快照 ），？并开始探索式执行。通过生成多个并行工作线程，探索性执行并发的搜索SR的最佳值，恢复原始固件执行，并将SR值返回给固件。

我们的挑战在于 构造一个可处理候选SR值搜索空间，确定探索性执行的范围（或工作的终止条件）；定义什么是最佳SR值，减少探索性执行的频率。

（1）构建搜索空间

通过包含SR的所有可能值，可以直观的构造搜索空间。利用这样一个事实，即SR中bit/flag位是独立的，并且一次只检查一个标志，所以构建了一个更小的，更易处理的搜索空间。我们的搜索空间只包含32+1个候选值，每个值在SR中设置一个单一的位加上一个0（所有位都清除？）探索性执行生成一个工作线程来测试每个候选值。在每个线程中，候选值作为SR的值返回给固件。所有工作线程并行执行，P2IM监控他们的进度，并在探索性执行结束时选出一个赢家（具有最佳候选值的线程）

（2）探索性工作线程终止

什么时候探索性执行应该终止工作线程是另一个设计问题 

不能太早也不能太迟，找到的：当他要返回下一个被调用的级别时，他会终止一个工作线程 （即 当当前调用堆栈帧（发生SR读的地方）被弹出时）它的基本原理是：固件通常在同一个函数中读取SR，然后根据SR的值决定是否可以执行进一步的ｉ／ｏ操作。因此，让探究性执行继续超出函数边界并不会为寻找最佳SR值带来好处。

在所有工作线程终止后，pim将确定哪些线程或候选SR值适合潜在的高级固件执行。然后在限定的值中选择最佳值返回到原始固件执行，从而结束探索性执行。 合格标准为1）线程没有crash或降速2）如果所有线程都崩溃，则选择由当前SR

固件可接受的输入值和解锁有意义的操作被用来代替真实的外设的输入，以实现pie

(3)通过SR分组最小化探究性执行：到目前为止讨论的探究性执行的设计是独立的处理单个SR访问

为每个SR的每次使用派生访问处理策略

根据上下文对sr访问进行分组，由（r,cs,bbl,conf）定义

r: SR    cs: SR访问调用堆栈的签名   bbl：发生SR读的基本块id conf：由SR访问时的CR值生成的外围配置散列。 



### **P2IM具体实现**

用qemu作为基本处理器模拟器

实现包括添加到qemu的2202行 C代码（主要用于动态固件执行工具）

​	用于fuzzer集成的173行 C代码

​	用于PIM探索性执行的1199行 python

​	在当前原型中使用AFL作为drop-in fuzzer,没有对MCU固件的内置支持或感知

在qemu的两个函数（unassigned_mem_read& unassigned_mem_write）实现了寄存器分类，外围设备标识，基于类型的寄存器访问处理和SR读分组逻辑。 其中对内存映射的外围设备寄存器访问被定向到这两个函数中，为了快速构建原型，使用python 实现了探索式执行的复杂逻辑。但工作线程仍然在qemu本地上运行。

中断识别和触发逻辑时基于qemu的虚拟中断控制器NVIC实现的，该逻辑监控固件 对 NVIC_ISERx NVIC_ICERx寄存器的访问，以检测启用的中断。他通过NVIC公开的armv7m)nvic_set_pending接口触发中断。

AFL仿真模式只支持用户模式仿真，这与固件仿真不兼容。Triforce AFL为AFL建立一个连接到qemu的完整系统仿真模式桥梁。本系统在实现框架的fuzzer集成部分使用了TriforceAFL的代码，该部分允许在不进行修改的情况下放入fuzzer。在运行期间，fuzzer集成代码通过DR访问将fuzzer生成的输入引导到固件执行，通过qemu工具收集代码覆盖信息，并将信息返回给fuzzer

### 评估

### 讨论

1）不能直接DMA

2）可以是arm以外的架构 mips， RISC-V 

3）超越模糊化的固件分析

### 相关工作

动态固件分析 Avatar Avatar2

静态固件分析 FIE   KLEE  符号执行

### 总结

这是一种对处理器外围接口的i/o建模技术。是第一个启用外设无关的模拟MCU设备，并反复嚄来，允许MCU固件动态测试与高代码覆盖率，在规模没有硬件依赖下，将ｐ２iM构建到一个框架里，该框架执行给定的固件二进制文件，