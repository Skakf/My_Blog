嵌入式固件综述

一、 固件 定义

二、 安全分析

二进制固件漏洞关联

- 基于模糊哈希
- 基于图匹配
- 基于学习
- 基于语义

静态分析

- **模糊哈希**？
- 污点分析
- 静态切片

---



**Firmalice**

Firmalice[54]使用静态程 序分析生成固件的程序依赖图，获取一个从入口点到特权程序点的认证切片，再通过符号执 行判断路径的约束中是否具有确定性的约束，如果存在，就可以认定为后门

 对静态分析得到的程序切片进行符号化执行分析，得到从程序入口点到特权程序点的所有执行路径，该作者是知名符号化引擎Angr的核心开发者，这里也是使用Angr进行的分析。 

 符号化执行引擎可以得到多条执行到程序特权点的路径上的约束，使用z3约束求解器对每条路径的约束求解。如果可以得到有限的解，则说明攻击者可以得到一组确定的输入使得程序可以执行某些特权操作，即说明存在认证旁路漏洞。 

 **认证旁路漏洞检测**

符号化执行引擎可以得到多条执行到程序特权点的路径上的约束，使用z3约束求解器对每条路径的约束求解。如果可以得到有限的解，则说明攻击者可以得到一组确定的输入使得程序可以执行某些特权操作，即说明存在认证旁路漏洞。

 作者在三个real-world的嵌入式设备上测试了Firmalice，成功的在两个设备中发现了存在的认证旁路漏洞，另外一个设备由于程序认证逻辑的比较复杂，未能成功检测出漏洞。
本文提出了一个新颖的认证旁路漏洞模型，通过程序切片技术将程序分析的目标缩小到认证逻辑相关的范围，使得可以对轻量级的切片程序进行符号化执行分析，解决了符号化执行无法分析复杂程序的问题。而且Firmalice提高了在检测固件认证旁路漏洞的自动化程度，减少了大量的人力工作。
但是Firmalice无法分析复杂的、混淆处理过的固件，这也是所有基于静态分析和符号化执行的工具所面临的问题。此外，Firmalice所能覆盖的认证旁路漏洞类型也比较有限，比如一些math-based认证旁路漏洞，由于约束可以求解出无穷个解，会被工具认为并不存在认证漏洞。通过在程序静态分析技术、符号化执行技术和约束求解器这几个方面进行技术升级，应该可以一定程度上提高Firmalice的适用面和准确度。 



Firmalice识别固件中存在的认证旁路漏洞需要以下五个步骤：

- 加载固件镜像文件。
- 解析人工提供的Security Policy，转换为对应的privileged program points。
- 静态分析固件程序，进行程序切片。
- 对切片程序进行符号化执行分析，获取执行特权操作的各条路径。
- 对各条路径上的约束求解分析，判断是否存在认证旁路漏洞。

---

针对污点类的漏洞，DTaint[83]首先将二进制固件转换为中间描述，对于每一个函数，通 过识别出指针化名、间接调用等方式，自底向上生成过程内和过程间的数据流图，并基于数 据流图，追踪 sinks，执行后向深度优化遍历，生成从 sinks 到 sources 的路径，通过检查路 径上的污点数据约束条件判断是否存在污点类型漏洞

FirmUSB[96] 使用 USB 协议的领域知识，为 8051/52 体系结构上的 USB 控制器固件专门设计一个符号执 行机制，FirmUSB 应用了两个符号执行框架：FIE 和 angr，通过静态分析和符号执行，**提取 出固件镜像中的语义以构建出固件的功能模型，与预期的功能进行比较，以确定是否存在漏 洞**。相比较于不受约束的符号执行，FirmUSB 的性能可以提升七倍。Firmalice[54]的主要思 想是利用符号执行去分析设备固件中登录认证相关的代码，得到可以进入特权状态的路径之 后，判断这些路径的约束中是否有确定性的约束，如果存在，就可以认定为后门

Inception[97]基于 KLEE 构建了一个 Inception 符号虚拟机，它将源码、汇编和库二进制 文件一起提升到 LLVM-IR，由 Inception 符号执行这个 LLVM-IR，以探测固件镜像中存在的 漏洞。结果显示, 该系统能够有效支持 ARM Cortex-M3 系统产品。

 Gerbil[100]是针对大规模 IoT 固件中存在的特权分离漏洞检测设计的，由于符号执行整个 IoT 固件几乎不可行，所以它首先**切片**出最有可能存在特权分离漏洞的代码部分，做符号执 行，而且在符号执行之上实现了一个路径探测框架，通过库函数识别机制，跳过复杂的库函 数以缓解路径爆炸并且可以恢复间接调用以探测更深的路径。

与之相似，为了克服固件仿真 的难题，FIoT[101]也使用了**后向代码切片**，遍历 IoT 固件的 CFG，构建包含从输入数据到敏 感函数调用路径的代码片段，交给符号执行，由符号执行来仿真固件的行为，进而再使用变 异数据替换源数据，进行动态模糊测试，以检测是否会触发内存破坏



，符号执行技术因为 依赖于很多重量级的分析组件(如反汇编引擎、插桩引擎、求解器)，很难直接在智能嵌入式 设备中直接使用，但可以结合一些领域知识、系统仿真、静态分析等间接方式来实现，比如 Gerbil 关注于可能发生特权分离漏洞的固件部分，FIoT 提取固件的控制流图，将一些敏感 操作函数作为漏洞触发点，对程序进行切片，Firmalice 对特权认证函数进行反向切片等， 约束了执行符号执行的代码规模，更有利于发挥符号执行的优势。 



FirmUp[46]提出 使用规一化的片段表示程序以解决跨编译器、跨优化选项、跨体系结构的问题，其主要方法 是将函数进行基本块级别的拆分，然后将基本块进一步切片成更小的片段，再将这种片段中 的寄存器名和地址偏移归一化，以函数为单位制成一张表，以两个表中相同的代码片段的数 量作为相似度比较的依据。为了提升效率，discovRE[42]提取更轻量级的语法级别特征来加速 特征提取，并且在图匹配之前通过简单的函数级特征进行预过滤，以提升搜索的效率。然而， 根据 Feng[47]，这种预过滤方法并不可靠，可能会产生很多的漏报，导致搜索精确度的严重 下降。理论上来说，这种依赖于 pairwise 图匹配来检测相似度的算法，必然是低效的



程序切片

软件开发人员在调试程序时经常会遇见这样的情形：他们在发现程序某处的某个变量的值发生了错误之后，需要去寻找所有可能引发了这个错误的程序语句—这同时也是程序切片的最初的应用场景。Mark D. Weiser提出的程序切片技术在实现上相对简单，其核心思想是通过数据流来计算程序切片。具体来说，就是首先计算程序变量和语句之间的定义-使用关系(def-use chain)，然后再从切片标准入手来跟踪定义-使用关系，从而获得所需的程序切片。

程序切片技术在其后几十年的发展过程中，主要经历了如下一些变化。

(1) 从静态到动态。

(2) 从前向到后向。

(3) 从单一过程到多个过程。

(4) 从非分布式程序到分布式程序。

一言以蔽之，不需要运行程序就可以完成的切片技术称为静态切片，而需要在程序运行时进行的切片技术称为动态切片。例如，我们可以考虑在程序的编译阶段执行静态切片—编译过程中既可以看到所有程序代码，同时还能够借助编译器得到代码间的某些依赖分析，因而是执行静态切片的一个好时机。

静态切片和动态切片各有优缺点，总结如下。

(1) 理论上，在程序运行过程中做程序切片会更加精准，因为此时能够准确地计算各种依赖关系。

(2) 虽然动态切片一般情况下会比静态切片更加精准，但受限于实现原理，它只能表示某次运行时的切片关系。

(3) 由于上述这个原因，动态切片需要考虑各个语句的多次执行实例。这就导致了动态切片技术理论上会比静态切片技术占用更多的存储空间。

---

