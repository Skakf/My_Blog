# FirmAE

### 解决5类问题：

- boot-related

- network-related

- NVRAM-related

- kernel-related

- minor-related

  arbitration techniques tp bypss the failure cases

following the original behavior or injecting proper interventions

---

对比：

firmadyne解包之后用自定义的linux内核和预先建立好的库，支持多种固件特性（包括NVRAM ）来仿真。为了仿真，仿真目标镜像两次，第一次，日志记录有用信息，第二次，利用记录的信息，因此，这个自定义的内核包括一个驱动，hook了主要大部分的系统调用去记录有效信息，例如，记录inet_ioctl(),inet_bind()去获取仿真固件用到的网络接口的名字和ip地址。

## 自定义的库同样包括硬件信息，例如，libnvram，存储并返回基于硬编码的默认值NVRAM value

发i现漏洞：已知漏洞，

实验对比：

FirmAE：仿真成功率提高，vul 复现的提高了，发现新漏洞

目标：运行成功更多的webservice,因为web service很重要

Firmadyne：针对已知漏洞，仿真成功率吧10%

---

## 概述：

### 创新点：提出5种方法，解决5类问题

### 方法：仲裁仿真 ， 启发式

### 结果：提高仿真成功率（从16.28%-79.36%）。320个已知漏洞 （比 F 多306个）+ 12个0day漏洞，影响23个设备

（1124 （1079 路由器+45 IP camera  F：183  // AE：892）

### 数据集：1,124 wireless-router and IP-camera firmware images from top eight vendors

8个厂商：分三类数据集（AnalysisSet , LatestSet , CamSet）

A：D-Link、TP-Link、netgear、

L：D-Link、TP-Link、netgear、Trendnet、ASUS、 Belkin、Linksys、Zyxel、

C：D-Link、TP-link、TrendNet

### 实验： 

关注web服务，因为web界面是远程攻击者可以交互的部分，在这些服务中发现了大量关键漏洞

### 解决方法：

强制设置参数，启发式系统化，开发一些仲裁技巧来绕过失败案例，代替严格遵守固件执行行为，可能会稍微改变固件的原始行为，但目标不是构建一个与物理设备相同的环境，而是创建一个有利于动态分析的环境。

设计好仲裁之后，将仿真过程自动化和并行化，

### 贡献：

1. 用经验研究了437个固件仿真失败案例，并将失败处理启发式方法系统化
2. 仲裁仿真，将启发式应用到仿真环境中，比F拥有更高的仿真成功率 892 vs 183
3. 覆盖306个漏洞，+ 95设备的23个新漏洞，12个是0day漏洞

---



## 背景知识：

### 1. 嵌入式设备分析过程

分为有/无物理设备 获取和分析目标固件

1）无

爬取固件，binwalk，Firmware-mod-kit解包

2）有 

用实际设备分析未打包的固件，对真实设备 外围访问，接口

3）分析固件但不用物理设备，来扩大分析

静态分析，由于缺少运行时信息，导致大量误报，还是动态分析好

动态分析在直接运行目标程序时识别漏洞，不会出现误报，但是仿真是个问题

### 2. 基于仿真的开发 分析

host ：进行仿真的系统被表示为 host system

guest： 被仿真的 叫 guest

两种级别仿真：用户级和系统级

- user-level emulation:

​	只模拟固件内的目标程序，并充分利用主机系统

​	eg：仿真web界面。web界面是嵌入式设备中用于设备管理和维护的代表性服务，提供多种静态内容，如 html，或CGI程序生成的动态内容。虽然，静态内容可以在主机环境中提供，但动态的不行，因为可能与宿主系统发生冲突，或者依赖宿主系统中不存在的自定义库和设备驱动程序

- system-level emulation:

​	完全模拟客户系统，包括内核。

​	提供了一个单独的执行环境，内核和设备驱动程序中的各种特性也可以被模拟。

​	但很困难，因为供应商硬件问题、内存映射外设、如果不处理，模拟固件中的程序经常会崩溃。

因此，近年来的研究试图创建尽可能与真实设备相似的仿真环境来解决问题

- Costin，可伸缩动态分析框架

- Firmadyne ： NVRAM 存储仿真固件中程序的各种配置值

安全分析：

TriForceAFL : 一种常见的fuzz ing qemu 镜像

AFL：

zheng提出用于动态分析的优化仿真方法，在系统级和用户级之间切换上下文



---

## Firmadyne

firmadyne解包之后用自定义的linux内核和预先建立好的库，支持多种固件特性（包括NVRAM ）来仿真。为了仿真，仿真目标镜像两次，第一次，日志记录有用信息，第二次，利用记录的信息，

因此，这个自定义的内核包括一个驱动，hook了主要大部分的系统调用 ，去记录有效信息，例如，记录inet_ioctl(),inet_bind()去获取仿真固件用到的网络接口的名字和ip地址。

> Ques：自定义的内核是啥？修改qemu,还是修改固件的内核？？？

自定义的库同样包括硬件信息，例如，libnvram，存储并返回基于硬编码的默认值NVRAM value

不足：网络可达性和web服务可用性 相当低（29.4% | 16.3%）

## 3. 设计与实现

goal：成功仿真，并运行他们的web服务

### 仲裁仿真

#### 关键思想：确保高级行为足以对内部程序执行动态分析，而不是查找和修复仿真失败的确切根源

#### 关键特性：干预（有意添加的操作）可能与物理设备行为不同，但可以绕过未解决的问题，假设这些问题不会强烈影响仿真固件中目标程序的行为



仲裁点：注入到仿真过程中的适当位置

由于干预关注的是高层次的行为，从一小组固件镜像中获得的干预可以广泛应用到其他发生类似故障的固件中

## FirmAE

### 架构图

![1606806811891](C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\1606806811891.png)

### 实现细节

两次模拟目标镜像，以收集各种系统日志并利用这些信息进一步的模拟。

前一个步骤称为预仿真，后一个称为最终仿真

每个仲裁的细节，并将仿真结果与F对比，

- 首先使用特定选项提取目标固件的文件系统

- 然后评估是否提取成功并检索体系结构信息

- Pre：预仿真，为qemu创建一个固件映像并收集信息

- Final：运行一个用于最终仿真 的脚本，并执行动态分析

- 自动化了所有交互，并为网络可达性和web服务可用性添加了一个自动化的评估过程。

- 在FirmAE中构建了一个定期运行的ping和curl命令

- **parallelization：利用docker容器化并行模拟，以有效的评估许多映像，每个固件映像在每个容器中独立运行，每个容器配备了所有必需的包和依赖，快速和可靠模拟目标镜像** 通过运行多个容器实例并行的模拟固件

- container：通过集装箱化，可以利用对主机和客户系统之间的网络连接进行抽象的优势，A在仿真过程中使用的Qemu，在主机系统中创建了一个额外的网络接口tap，此接口链接到其中一个客户网络接口，因此，每个模拟的固件在主机系统中都拥有一个具有唯一IP地址的独立tap接口，否则会发生网络冲突。

- 集装箱化隔离了每个容器的网络环境，因此，即使在并行模拟中，也可以正确地将来自主机系统的数据包路由放到客户机，

- 还将检查器和分析引擎放在每个容器里

- > Ques：啥是tap接口啊？？？

## 4. 方法

启动 init

​	从内核和文件系统提取字符串，根据路径准备文件结构

nvram：

1）搜索 文件

2）返回一个指向空字符串的指针

网络：

内核：修改版本

## 5. 实验

5种方法同时开启

一次减少一种，判断减少哪种对提高仿真率影响最大，来判断那种方法最有效

NVRAM-35%, 影响最大



