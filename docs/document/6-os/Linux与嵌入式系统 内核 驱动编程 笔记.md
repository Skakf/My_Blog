# Linux与嵌入式系统 内核 驱动编程 笔记

### 环境：source insight3.5

![1584604183383](../../imgs/1584604183383.png)

## 简单驱动编写

1. 编写驱动代码

![1584436111530](../../imgs/1584436111530.png)

2. 编写makefile

   ![1584454126802](../../imgs/1584454126802.png)

3. 编译

   insmod hello.ko

   rmmod hello                  //注意卸载不用.ko

   报错就缺啥路径创建啥路径

4. 装载

   传参，可以在原来的里面设置，也可以从外面传进去

   ![1584457825121](../../imgs/1584457825121.png)

   ![1584516055768](../../imgs/1584516055768.png)

驱动或者模块之间相互调用

![1584516292657](../../imgs/1584516292657.png)

math.c

![1584516762369](../../imgs/1584516762369.png)

math.h(声明)

![1584516491946](../../imgs/1584516491946.png)

原hello里补充

![1584516833140](../../imgs/1584516833140.png)

![1584516585794](../../imgs/1584516585794.png)

makefile

![1584516366000](../../imgs/1584516366000.png)

insmod 导出到符号表才可以

直接先安装hello.ko不行，必须还要安装math.ko

![1584516943264](../../imgs/1584516943264.png)

![1584516977530](../../imgs/1584516977530.png)

![1584516617397](../../imgs/1584516617397.png)

------

## Day 4

![1584517426153](../../imgs/1584517426153.png)

### 一、字符设备驱动框架

有很多设备，设备号用来标识设备

用户空间对驱动的操作实际就是文件IO

设备号，设备名，设备节点（/dev/led0）

![1584520559493](../../imgs/1584520559493.png)

![1584520471612](../../imgs/1584520471612.png)



### 二、申请设备号

![1584521234365](../../imgs/1584521234365.png)

### 代码

主设备号（表示一类）+此设备号（表示该类中的某一个）

![1584521087056](../../imgs/1584521087056.png)

代码：框架   加头文件#include<fs.h>

![1584521644905](../../imgs/1584521644905.png)

![1584521758499](../../imgs/1584521758499.png)

Makefile：

![1584521837500](../../imgs/1584521837500.png)

make

![1584522081262](../../imgs/1584522081262.png)

主设备号，高12位，次设备号，低12位

### 三、申请设备节点

代码用法：先静态声明，之后有使用和释放

![1584523030392](../../imgs/1584523030392.png)

![1584523199099](../../imgs/1584523199099.png)

笔记

![1584523374271](../../imgs/1584523374271.png)

![1584523471876](../../imgs/1584523471876.png)

![1584523624746](../../imgs/1584523624746.png)

### 四、文件操作

![1584523815248](../../imgs/1584523815248.png)

把他们当作对象，有好多接口

![1584524109899](../../imgs/1584524109899.png)

![1584524192384](../../imgs/1584524192384.png)

![1584524362857](../../imgs/1584524362857.png)

![1584524433148](../../imgs/1584524433148.png)

如何印证，驱动调用了新添加的open等操作

下一讲写个应用程序调用一下，印证

![1584524295439](../../imgs/1584524295439.png)

### Day 5

man read /open (手册有头文件和需要的参数)

char_test.c -应用程序

![1584614779415](../../imgs/1584614779415.png)

makefile

![1584614692059](../../imgs/1584614692059.png)

应用程序和驱动都要安装进去，让应用程序，可以调用驱动接口

笔记

![1584615716211](../../imgs/1584615716211.png)

![1584616768425](../../imgs/1584616768425.png)

![1584630470101](../../imgs/1584630470101.png)

内核控制外设的方法：地址映射ioremap-用户操作虚拟地址，转化成物理地址，最后操作外设

![1584631008643](../../imgs/1584631008643.png)

![1584631208956](../../imgs/1584631208956.png)连续映射一片地址所以要给个长度

![1584631387548](../../imgs/1584631387548.png)

加载驱动时加映射，卸载时解除映射

例子：led灯

![1584631867480](../../imgs/1584631867480.png)

首先，引脚-接口，寄存器-转换成物理地址  （公式）

![1584631739266](../../imgs/1584631739266.png)

写驱动程序，给接口写0写1，完成一闪一闪亮晶晶（加头文件io.h）

![1584632452736](../../imgs/1584632452736.png)

应用程序控制灯的亮灭，调用驱动程序

![1584632665098](../../imgs/1584632665098.png)



![1584632518575](../../imgs/1584632518575.png)